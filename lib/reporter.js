// Generated by MambaScript 0.1.1 
var present = console.log; 
// Generated by MambaScript 0.1.1 
var debug, pj, render, Reporter, TypeError;
pj = function () {
  try {
    return require('prettyjson');
  } catch (e$) {
    return;
  }
}.call(this);
render = function (obj) {
  if (null != pj)
    return pj.render(obj);
};
TypeError = require('./type-helpers').TypeError;
debug = require('./helpers').debug;
require('colors');
Reporter = function () {
  function Reporter() {
    var instance$;
    instance$ = this;
    this.add_warning = function (a, b) {
      return Reporter.prototype.add_warning.apply(instance$, arguments);
    };
    this.clean = function () {
      return Reporter.prototype.clean.apply(instance$, arguments);
    };
    this.add_error = function (a, b) {
      return Reporter.prototype.add_error.apply(instance$, arguments);
    };
    this.errors = [];
    this.warnings = [];
  }
  Reporter.prototype.has_errors = function () {
    this.errors = this.errors.filter(function (param$) {
      var cache$, node, text;
      {
        cache$ = param$;
        node = cache$[0];
        text = cache$[1];
      }
      return node.raw === true;
    });
    return this.errors.length > 0;
  };
  Reporter.prototype.has_warnings = function () {
    this.warnings = this.warnings.filter(function (param$) {
      var cache$, node, text;
      {
        cache$ = param$;
        node = cache$[0];
        text = cache$[1];
      }
      return node.raw === true;
    });
    return this.warnings.length > 0;
  };
  Reporter.prototype.report = function () {
    var errors;
    errors = this.errors.map(function (param$) {
      var cache$, node, text;
      {
        cache$ = param$;
        node = cache$[0];
        text = cache$[1];
      }
      return 'L' + node.line + ' ' + node.raw.inverse + ' ' + text.red + ' If you think that you found a bug in the language this error is generated from src/reporter.mamba help me improve it... this reporter is exported and used around the whole language';
    });
    return '' + errors.join('\n') + '';
  };
  Reporter.prototype.add_error = function (node, text) {
    return this.errors.push([
      node,
      text
    ]);
  };
  Reporter.prototype.clean = function () {
    return this.errors = [];
  };
  Reporter.prototype.add_warning = function (node) {
    var ws;
    ws = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
    return this.warnings.push([
      node,
      ws.join('')
    ]);
  };
  Reporter.prototype.dump = function (node, prefix) {
    var key, next, prop, type, val;
    if (null == prefix)
      prefix = '';
    console.error(prefix + ('[' + node.name + ']'));
    console.error(prefix, ' vars::');
    for (key in node._vars) {
      val = node._vars[key];
      console.error(prefix, ' +', key, '::', JSON.stringify(val));
    }
    console.error(prefix, ' types::');
    for (var i$ = 0, length$ = node._types.length; i$ < length$; ++i$) {
      type = node._types[i$];
      console.error(prefix, ' +', type.identifier.typeName);
      if (type.properties)
        for (var i$1 = 0, length$1 = type.properties.length; i$1 < length$1; ++i$1) {
          prop = type.properties[i$1];
          console.error(prefix, '    @', prop.identifier.typeName, prop.typeAnnotation);
        }
    }
    return function (accum$) {
      for (var i$2 = 0, length$2 = node.nodes.length; i$2 < length$2; ++i$2) {
        next = node.nodes[i$2];
        accum$.push(this.dump(next, prefix + '  '));
      }
      return accum$;
    }.call(this, []);
  };
  return Reporter;
}();
module.exports = new Reporter;
