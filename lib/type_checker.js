// Generated by CoffeeScript 2.0.0-beta8-dev
var checkNodes, ClassScope, console, CS, FunctionScope, g, initializeGlobalTypes, pj, render, reporter, Scope, walk, walk_arrayInializer, walk_assignOp, walk_binOp, walk_block, walk_bool, walk_class, walk_classProtoAssignOp, walk_conditional, walk_for, walk_function, walk_functionApplication, walk_identifier, walk_memberAccess, walk_newOp, walk_numbers, walk_objectInitializer, walk_primitives, walk_program, walk_range, walk_return, walk_string, walk_struct, walk_switch, walk_this, walk_vardef;
console = {
  log: function () {
  }
};
pj = function () {
  try {
    return require('prettyjson');
  } catch (e$) {
    return;
  }
}.call(this);
render = function (obj) {
  if (null != pj)
    return pj.render(obj);
};
reporter = require('./reporter');
CS = require('./nodes');
cache$ = require('./types');
initializeGlobalTypes = cache$.initializeGlobalTypes;
Scope = cache$.Scope;
ClassScope = cache$.ClassScope;
FunctionScope = cache$.FunctionScope;
g = 'undefined' !== typeof window && null != window ? window : global;
checkNodes = function (cs_ast) {
  var i, root;
  if (!(null != (null != cs_ast.body ? cs_ast.body.statements : void 0)))
    return;
  if (g._root_) {
    root = g._root_;
  } else {
    g._root_ = root = new Scope;
    root.name = 'root';
    for (var cache$1 = [
          'global',
          'exports',
          'module'
        ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
      i = cache$1[i$];
      root.addVar(i, 'Any', true);
    }
    initializeGlobalTypes(root);
  }
  walk(cs_ast, root);
  return root;
};
walk_struct = function (node, scope) {
  if (node.name instanceof Object) {
    return scope.addType(node.name._base_, node.expr, node.name._templates_);
  } else {
    return scope.addType(node.name, node.expr);
  }
};
walk_vardef = function (node, scope) {
  var symbol;
  symbol = node.name === 'constructor' ? '_constructor_' : node.name;
  console.log('vardef', node.name, symbol);
  if (scope instanceof ClassScope) {
    return scope.addThis(symbol, node.expr);
  } else {
    return scope.addVar(symbol, node.expr);
  }
};
walk_program = function (node, scope) {
  walk(node.body.statements, scope);
  return node.annotation = { type: 'Program' };
};
walk_block = function (node, scope) {
  var last_annotation;
  walk(node.statements, scope);
  last_annotation = null != node.statements[node.statements.length - 1] ? node.statements[node.statements.length - 1].annotation : void 0;
  return node.annotation = last_annotation;
};
walk_return = function (node, scope) {
  walk(node.expression, scope);
  if (null != (null != node.expression && null != node.expression.annotation ? node.expression.annotation.type : void 0)) {
    scope.addReturnable(node.expression.annotation.type);
    return node.annotation = node.expression.annotation;
  }
};
walk_binOp = function (node, scope) {
  var left_type, right_type;
  walk(node.left, scope);
  walk(node.right, scope);
  left_type = null != node.left && null != node.left.annotation ? node.left.annotation.type : void 0;
  right_type = null != node.right && null != node.right.annotation ? node.right.annotation.type : void 0;
  if (left_type && right_type) {
    if (left_type === 'String' || right_type === 'String') {
      return node.annotation = { type: 'String' };
    } else if (left_type === right_type) {
      return node.annotation = { type: left_type };
    }
  } else {
    return node.annotation = { type: 'Any' };
  }
};
walk_conditional = function (node, scope) {
  var alternate_annotation, annotation, possibilities, type;
  walk(node.condition, scope);
  walk(node.consequent, scope);
  if (null != node.alternate)
    walk(node.alternate, scope);
  alternate_annotation = null != (null != node.alternate ? node.alternate.annotation : void 0) ? null != node.alternate ? node.alternate.annotation : void 0 : { type: 'Undefined' };
  possibilities = [];
  for (var cache$1 = [
        null != node.consequent ? node.consequent.annotation : void 0,
        alternate_annotation
      ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
    annotation = cache$1[i$];
    if (!('undefined' !== typeof annotation && null != annotation))
      continue;
    if (null != (null != annotation.type ? annotation.type.possibilities : void 0)) {
      for (var i$1 = 0, length$1 = annotation.type.possibilities.length; i$1 < length$1; ++i$1) {
        type = annotation.type.possibilities[i$1];
        possibilities.push(type);
      }
    } else if (null != annotation.type) {
      possibilities.push(annotation.type);
    }
  }
  return node.annotation = { type: { possibilities: possibilities } };
};
walk_switch = function (node, scope) {
  var alternate_annotation, c, cond, possibilities;
  walk(node.expression, scope);
  for (var i$ = 0, length$ = node.cases.length; i$ < length$; ++i$) {
    c = node.cases[i$];
    for (var i$1 = 0, length$1 = c.conditions.length; i$1 < length$1; ++i$1) {
      cond = c.conditions[i$1];
      walk(c, scope);
    }
    walk(c.consequent, scope);
  }
  walk(node.consequent, scope);
  if (null != node.alternate)
    walk(node.alternate, scope);
  alternate_annotation = null != (null != node.alternate ? node.alternate.annotation : void 0) ? null != node.alternate ? node.alternate.annotation : void 0 : { type: 'Undefined' };
  possibilities = [];
  for (var i$2 = 0, length$2 = node.cases.length; i$2 < length$2; ++i$2) {
    c = node.cases[i$2];
    if (!(null != c.annotation))
      continue;
    possibilities.push(c.consequent.annotation);
  }
  possibilities.push(alternate_annotation.type);
  return node.annotation = { type: { possibilities: possibilities } };
};
walk_newOp = function (node, scope) {
  var _args_, arg, err, Type;
  for (var i$ = 0, length$ = node['arguments'].length; i$ < length$; ++i$) {
    arg = node['arguments'][i$];
    walk(arg, scope);
  }
  console.log('newOp');
  console.log(render(node));
  Type = scope.getTypeInScope(node.ctor.data);
  if (Type) {
    _args_ = null != node['arguments'] ? node['arguments'].map(function (arg) {
      return null != arg.annotation ? arg.annotation.type : void 0;
    }) : void 0;
    console.log('constructor', Type.type._constructor_);
    console.log('args', {
      _args_: null != _args_ ? _args_ : [],
      _return_: 'Any'
    });
    if (err = scope.checkAcceptableObject(Type.type._constructor_, {
        _args_: null != _args_ ? _args_ : [],
        _return_: 'Any'
      }))
      return reporter.add_error(node, err);
  }
  return node.annotation = { type: null != Type ? Type.type : void 0 };
};
walk_for = function (node, scope) {
  var err, nop, type;
  walk(node.target, scope);
  if (null != node.valAssignee)
    scope.addVar(node.valAssignee.data, null != (null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.type : void 0) ? null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.type : void 0 : 'Any');
  if (null != node.keyAssignee)
    scope.addVar(node.keyAssignee.data, null != (null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.type : void 0) ? null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.type : void 0 : 'Any');
  if (null != node.valAssignee)
    if (null != (null != node.target.annotation && null != node.target.annotation.type ? node.target.annotation.type.array : void 0)) {
      if (err = scope.checkAcceptableObject(node.valAssignee.annotation.type, node.target.annotation.type.array)) {
        return reporter.add_error(node, err);
      }
    } else if ((null != node.target && null != node.target.annotation ? node.target.annotation.type : void 0) instanceof Object) {
      if (node.target.annotation.type instanceof Object) {
        for (nop in node.target.annotation.type) {
          type = node.target.annotation.type[nop];
          if (err = scope.checkAcceptableObject(node.valAssignee.annotation.type, type))
            return reporter.add_error(node, err);
        }
      }
    }
  walk(node.body, scope);
  node.annotation = null != node.target ? node.target.annotation : void 0;
  delete scope._vars[null != node.valAssignee ? node.valAssignee.data : void 0];
  return delete scope._vars[null != node.keyAssignee ? node.keyAssignee.data : void 0];
};
walk_classProtoAssignOp = function (node, scope) {
  var left, right, symbol;
  left = node.assignee;
  right = node.expression;
  symbol = left.data;
  walk(left, scope);
  if (right['instanceof'](CS.Function) && scope.getThis(symbol)) {
    walk_function(right, scope, scope.getThis(symbol).type);
  } else {
    walk(right, scope);
  }
  symbol = left.data;
  if (null != right.annotation)
    return scope.addThis(symbol, right.annotation.type);
};
walk_assignOp = function (node, scope) {
  var err, left, pre_registered_annotation, right, symbol, T;
  pre_registered_annotation = node.assignee.annotation;
  left = node.assignee;
  right = node.expression;
  symbol = left.data;
  walk(left, scope);
  if (('function' === typeof right['instanceof'] ? right['instanceof'](CS.Function) : void 0) && scope.getVarInScope(symbol)) {
    walk_function(right, scope, scope.getVarInScope(symbol).type);
  } else if (('function' === typeof right['instanceof'] ? right['instanceof'](CS.Function) : void 0) && pre_registered_annotation) {
    walk_function(right, scope, left.annotation.type);
  } else {
    walk(right, scope);
  }
  if (left['instanceof'](CS.MemberAccessOp)) {
    if (left.expression['instanceof'](CS.This)) {
      T = scope.getThis(left.memberName);
      if (null != T)
        left.annotation = T;
      if (null != T)
        if (err = scope.checkAcceptableObject(left.annotation.type, right.annotation.type)) {
          return reporter.add_error(node, err);
        }
      return;
    } else if (null != (null != left.annotation ? left.annotation.type : void 0) && null != (null != right.annotation ? right.annotation.type : void 0)) {
      if (left.annotation.type !== 'Any') {
        if (err = scope.checkAcceptableObject(left.annotation.type, right.annotation.type)) {
          return reporter.add_error(node, err);
        }
      }
    }
  } else if (left['instanceof'](CS.Identifier)) {
    symbol = left.data;
    if (scope.getVarInScope(symbol) && pre_registered_annotation)
      return report.add_error(node, 'double bind: ' + symbol);
    scope.addVar(symbol, left.annotation.type);
    if (null != left.annotation.type)
      if (left.annotation.type === 'Any') {
        return scope.addVar(symbol, 'Any', true);
      } else {
        if (null != right.annotation && null != left.annotation)
          if (err = scope.checkAcceptableObject(left.annotation.type, right.annotation.type)) {
            return reporter.add_error(node, err);
          }
        return scope.addVar(symbol, left.annotation.type);
      }
  } else {
    return scope.addVar(symbol, 'Any');
  }
};
walk_primitives = function (node, scope) {
  switch (false) {
  case !node['instanceof'](CS.String):
    return walk_string(node, scope);
  case !node['instanceof'](CS.Bool):
    return walk_bool(node, scope);
  case !node['instanceof'](CS.Numbers):
    return walk_numbers(node, scope);
  }
};
walk_string = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    type: 'String',
    primitive: true
  };
};
walk_numbers = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    type: 'Number',
    primitive: true
  };
};
walk_bool = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    type: 'Boolean',
    primitive: true
  };
};
walk_identifier = function (node, scope) {
  var Var;
  if (scope.getVarInScope(node.data)) {
    Var = scope.getVarInScope(node.data);
    return node.annotation = { type: null != Var ? Var.type : void 0 };
  } else {
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = { type: 'Any' };
  }
};
walk_this = function (node, scope) {
  var key, type, val;
  type = {};
  for (key in scope._this) {
    val = scope._this[key];
    type[key] = val.type;
  }
  return null != node.annotation ? node.annotation : node.annotation = { type: type };
};
walk_memberAccess = function (node, scope) {
  var type;
  if (node['instanceof'](CS.SoakedMemberAccessOp)) {
    walk(node.expression, scope);
    type = scope.extendTypeLiteral(null != node.expression.annotation ? node.expression.annotation.type : void 0);
    if (null != type) {
      return node.annotation = {
        type: {
          possibilities: [
            'Undefined',
            type[node.memberName]
          ]
        }
      };
    } else {
      return node.annotation = { type: 'Any' };
    }
  } else if (node['instanceof'](CS.MemberAccessOp)) {
    walk(node.expression, scope);
    type = scope.extendTypeLiteral(null != node.expression.annotation ? node.expression.annotation.type : void 0);
    if (null != type) {
      return node.annotation = { type: type[node.memberName] };
    } else {
      return node.annotation = { type: 'Any' };
    }
  }
};
walk_arrayInializer = function (node, scope) {
  walk(node.members, scope);
  return null != node.annotation ? node.annotation : node.annotation = {
    type: {
      array: null != node.members ? node.members.map(function (m) {
        return null != m.annotation ? m.annotation.type : void 0;
      }) : void 0
    }
  };
};
walk_range = function (node, scope) {
  return node.annotation = { type: { array: 'Number' } };
};
walk_objectInitializer = function (node, scope) {
  var cache$1, expression, key, nextScope, obj;
  obj = {};
  nextScope = new Scope(scope);
  nextScope.name = 'object';
  for (var i$ = 0, length$ = node.members.length; i$ < length$; ++i$) {
    {
      cache$1 = node.members[i$];
      expression = cache$1.expression;
      key = cache$1.key;
    }
    if (!('undefined' !== typeof key && null != key))
      continue;
    walk(expression, nextScope);
    obj[key.data] = null != expression.annotation ? expression.annotation.type : void 0;
  }
  return null != node.annotation ? node.annotation : node.annotation = { type: obj };
};
walk_class = function (node, scope) {
  var classScope, constructorScope, fname, index, obj, param, statement, val;
  classScope = new ClassScope(scope);
  if (null != (null != node.body ? node.body.statements : void 0))
    for (var i$ = 0, length$ = node.body.statements.length; i$ < length$; ++i$) {
      statement = node.body.statements[i$];
      if (!(statement.type === 'vardef'))
        continue;
      walk_vardef(statement, classScope);
    }
  if (null != node.ctor) {
    constructorScope = new FunctionScope(classScope);
    constructorScope._this = classScope._this;
    if (null != node.ctor.expression.parameters)
      for (var i$1 = 0, length$1 = node.ctor.expression.parameters.length; i$1 < length$1; ++i$1) {
        param = node.ctor.expression.parameters[i$1];
        index = i$1;
        walk(param, constructorScope);
        constructorScope.addVar(param.data, null != ('undefined' !== typeof param && null != param && null != param.annotation ? param.annotation.type : void 0) ? 'undefined' !== typeof param && null != param && null != param.annotation ? param.annotation.type : void 0 : 'Any');
      }
    if (null != (null != node.ctor.expression.body ? node.ctor.expression.body.statements : void 0))
      for (var i$2 = 0, length$2 = node.ctor.expression.body.statements.length; i$2 < length$2; ++i$2) {
        statement = node.ctor.expression.body.statements[i$2];
        walk(statement, constructorScope);
      }
  }
  if (null != (null != node.body ? node.body.statements : void 0))
    for (var i$3 = 0, length$3 = node.body.statements.length; i$3 < length$3; ++i$3) {
      statement = node.body.statements[i$3];
      if (!(statement.type !== 'vardef'))
        continue;
      walk(statement, classScope);
    }
  if (null != node.nameAssignee ? node.nameAssignee.data : void 0) {
    obj = {};
    for (fname in classScope._this) {
      val = classScope._this[fname];
      obj[fname] = val.type;
    }
    return scope.addType(node.nameAssignee.data, obj);
  }
};
walk_function = function (node, scope, predef) {
  var _args_, err, functionScope, index, last_expr, param;
  if (null == predef)
    predef = null;
  _args_ = null != node.parameters ? node.parameters.map(function (param) {
    return null != (null != param.annotation ? param.annotation.type : void 0) ? null != param.annotation ? param.annotation.type : void 0 : 'Any';
  }) : void 0;
  node.annotation.type._args_ = _args_;
  functionScope = new Scope(scope);
  functionScope._name_ = 'function';
  if (scope instanceof ClassScope)
    functionScope._this = scope._this;
  if (null != node.parameters)
    if (predef) {
      node.annotation.type = predef;
      for (var i$ = 0, length$ = node.parameters.length; i$ < length$; ++i$) {
        param = node.parameters[i$];
        index = i$;
        functionScope.addVar(param.data, null != (null != predef._args_ ? predef._args_[index] : void 0) ? null != predef._args_ ? predef._args_[index] : void 0 : 'Any');
      }
    } else {
      for (var i$1 = 0, length$1 = node.parameters.length; i$1 < length$1; ++i$1) {
        param = node.parameters[i$1];
        index = i$1;
        functionScope.addVar(param.data, null != (null != param && null != param.annotation ? param.annotation.type : void 0) ? null != param && null != param.annotation ? param.annotation.type : void 0 : 'Any');
      }
    }
  walk(node.body, functionScope);
  if ((null != node.annotation && null != node.annotation.type ? node.annotation.type._return_ : void 0) !== 'Any') {
    last_expr = (null != node.body && null != node.body.statements ? node.body.statements.length : void 0) ? null != node.body.statements ? node.body.statements[(null != node.body && null != node.body.statements ? node.body.statements.length : void 0) - 1] : void 0 : node.body;
    if (err = scope.checkAcceptableObject(null != node.annotation ? node.annotation.type._return_ : void 0, null != last_expr && null != last_expr.annotation ? last_expr.annotation.type : void 0))
      return reporter.add_error(node, err);
  } else {
    last_expr = (null != node.body && null != node.body.statements ? node.body.statements.length : void 0) ? null != node.body.statements ? node.body.statements[(null != node.body && null != node.body.statements ? node.body.statements.length : void 0) - 1] : void 0 : node.body;
    if (null != node.annotation)
      return node.annotation.type._return_ = null != last_expr && null != last_expr.annotation ? last_expr.annotation.type : void 0;
  }
};
walk_functionApplication = function (node, scope) {
  var _args_, arg, err;
  for (var i$ = 0, length$ = node['arguments'].length; i$ < length$; ++i$) {
    arg = node['arguments'][i$];
    walk(arg, scope);
  }
  walk(node['function'], scope);
  node.annotation = { type: null != node['function'].annotation && null != node['function'].annotation.type ? node['function'].annotation.type._return_ : void 0 };
  if (node['function'].annotation) {
    _args_ = null != node['arguments'] ? node['arguments'].map(function (arg) {
      return null != arg.annotation ? arg.annotation.type : void 0;
    }) : void 0;
    if (err = scope.checkAcceptableObject(node['function'].annotation.type, {
        _args_: null != _args_ ? _args_ : [],
        _return_: 'Any'
      }))
      return reporter.add_error(node, err);
  }
};
walk = function (node, scope) {
  console.log('---', null != node ? node.className : void 0, '---');
  switch (false) {
  case !!(null != node):
    return;
  case !(null != node.length):
    return function (accum$) {
      var s;
      for (var i$ = 0, length$ = node.length; i$ < length$; ++i$) {
        s = node[i$];
        accum$.push(walk(s, scope));
      }
      return accum$;
    }.call(this, []);
  case !(node.type === 'struct'):
    return walk_struct(node, scope);
  case !(node.type === 'vardef'):
    return walk_vardef(node, scope);
  case !node['instanceof'](CS.Program):
    return walk_program(node, scope);
  case !node['instanceof'](CS.Block):
    return walk_block(node, scope);
  case !node['instanceof'](CS.Return):
    return walk_return(node, scope);
  case !node['instanceof'](CS.NewOp):
    return walk_newOp(node, scope);
  case !(node['instanceof'](CS.PlusOp) || node['instanceof'](CS.MultiplyOp) || node['instanceof'](CS.DivideOp) || node['instanceof'](CS.SubtractOp)):
    return walk_binOp(node, scope);
  case !node['instanceof'](CS.Switch):
    return walk_switch(node, scope);
  case !node['instanceof'](CS.Conditional):
    return walk_conditional(node, scope);
  case !(node['instanceof'](CS.ForIn) || node['instanceof'](CS.ForOf)):
    return walk_for(node, scope);
  case !node['instanceof'](CS.Primitives):
    return walk_primitives(node, scope);
  case !node['instanceof'](CS.This):
    return walk_this(node, scope);
  case !node['instanceof'](CS.Identifier):
    return walk_identifier(node, scope);
  case !node['instanceof'](CS.ClassProtoAssignOp):
    return walk_classProtoAssignOp(node, scope);
  case !node['instanceof'](CS.MemberAccessOps):
    return walk_memberAccess(node, scope);
  case !node['instanceof'](CS.ArrayInitialiser):
    return walk_arrayInializer(node, scope);
  case !node['instanceof'](CS.Range):
    return walk_range(node, scope);
  case !node['instanceof'](CS.ObjectInitialiser):
    return walk_objectInitializer(node, scope);
  case !node['instanceof'](CS.Class):
    return walk_class(node, scope);
  case !node['instanceof'](CS.Function):
    return walk_function(node, scope);
  case !node['instanceof'](CS.FunctionApplication):
    return walk_functionApplication(node, scope);
  case !node['instanceof'](CS.AssignOp):
    return walk_assignOp(node, scope);
  }
};
module.exports = { checkNodes: checkNodes };
